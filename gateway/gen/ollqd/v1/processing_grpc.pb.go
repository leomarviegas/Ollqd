// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.4
// source: ollqd/v1/processing.proto

package ollqdv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	IndexingService_IndexCodebase_FullMethodName  = "/ollqd.v1.IndexingService/IndexCodebase"
	IndexingService_IndexDocuments_FullMethodName = "/ollqd.v1.IndexingService/IndexDocuments"
	IndexingService_IndexImages_FullMethodName    = "/ollqd.v1.IndexingService/IndexImages"
	IndexingService_IndexUploads_FullMethodName   = "/ollqd.v1.IndexingService/IndexUploads"
	IndexingService_IndexSMBFiles_FullMethodName  = "/ollqd.v1.IndexingService/IndexSMBFiles"
	IndexingService_CancelTask_FullMethodName     = "/ollqd.v1.IndexingService/CancelTask"
)

// IndexingServiceClient is the client API for IndexingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IndexingServiceClient interface {
	IndexCodebase(ctx context.Context, in *IndexCodebaseRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskProgress], error)
	IndexDocuments(ctx context.Context, in *IndexDocumentsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskProgress], error)
	IndexImages(ctx context.Context, in *IndexImagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskProgress], error)
	IndexUploads(ctx context.Context, in *IndexUploadsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskProgress], error)
	IndexSMBFiles(ctx context.Context, in *IndexSMBFilesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskProgress], error)
	CancelTask(ctx context.Context, in *CancelTaskRequest, opts ...grpc.CallOption) (*CancelTaskResponse, error)
}

type indexingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIndexingServiceClient(cc grpc.ClientConnInterface) IndexingServiceClient {
	return &indexingServiceClient{cc}
}

func (c *indexingServiceClient) IndexCodebase(ctx context.Context, in *IndexCodebaseRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &IndexingService_ServiceDesc.Streams[0], IndexingService_IndexCodebase_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[IndexCodebaseRequest, TaskProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type IndexingService_IndexCodebaseClient = grpc.ServerStreamingClient[TaskProgress]

func (c *indexingServiceClient) IndexDocuments(ctx context.Context, in *IndexDocumentsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &IndexingService_ServiceDesc.Streams[1], IndexingService_IndexDocuments_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[IndexDocumentsRequest, TaskProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type IndexingService_IndexDocumentsClient = grpc.ServerStreamingClient[TaskProgress]

func (c *indexingServiceClient) IndexImages(ctx context.Context, in *IndexImagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &IndexingService_ServiceDesc.Streams[2], IndexingService_IndexImages_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[IndexImagesRequest, TaskProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type IndexingService_IndexImagesClient = grpc.ServerStreamingClient[TaskProgress]

func (c *indexingServiceClient) IndexUploads(ctx context.Context, in *IndexUploadsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &IndexingService_ServiceDesc.Streams[3], IndexingService_IndexUploads_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[IndexUploadsRequest, TaskProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type IndexingService_IndexUploadsClient = grpc.ServerStreamingClient[TaskProgress]

func (c *indexingServiceClient) IndexSMBFiles(ctx context.Context, in *IndexSMBFilesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &IndexingService_ServiceDesc.Streams[4], IndexingService_IndexSMBFiles_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[IndexSMBFilesRequest, TaskProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type IndexingService_IndexSMBFilesClient = grpc.ServerStreamingClient[TaskProgress]

func (c *indexingServiceClient) CancelTask(ctx context.Context, in *CancelTaskRequest, opts ...grpc.CallOption) (*CancelTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelTaskResponse)
	err := c.cc.Invoke(ctx, IndexingService_CancelTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IndexingServiceServer is the server API for IndexingService service.
// All implementations must embed UnimplementedIndexingServiceServer
// for forward compatibility.
type IndexingServiceServer interface {
	IndexCodebase(*IndexCodebaseRequest, grpc.ServerStreamingServer[TaskProgress]) error
	IndexDocuments(*IndexDocumentsRequest, grpc.ServerStreamingServer[TaskProgress]) error
	IndexImages(*IndexImagesRequest, grpc.ServerStreamingServer[TaskProgress]) error
	IndexUploads(*IndexUploadsRequest, grpc.ServerStreamingServer[TaskProgress]) error
	IndexSMBFiles(*IndexSMBFilesRequest, grpc.ServerStreamingServer[TaskProgress]) error
	CancelTask(context.Context, *CancelTaskRequest) (*CancelTaskResponse, error)
	mustEmbedUnimplementedIndexingServiceServer()
}

// UnimplementedIndexingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedIndexingServiceServer struct{}

func (UnimplementedIndexingServiceServer) IndexCodebase(*IndexCodebaseRequest, grpc.ServerStreamingServer[TaskProgress]) error {
	return status.Error(codes.Unimplemented, "method IndexCodebase not implemented")
}
func (UnimplementedIndexingServiceServer) IndexDocuments(*IndexDocumentsRequest, grpc.ServerStreamingServer[TaskProgress]) error {
	return status.Error(codes.Unimplemented, "method IndexDocuments not implemented")
}
func (UnimplementedIndexingServiceServer) IndexImages(*IndexImagesRequest, grpc.ServerStreamingServer[TaskProgress]) error {
	return status.Error(codes.Unimplemented, "method IndexImages not implemented")
}
func (UnimplementedIndexingServiceServer) IndexUploads(*IndexUploadsRequest, grpc.ServerStreamingServer[TaskProgress]) error {
	return status.Error(codes.Unimplemented, "method IndexUploads not implemented")
}
func (UnimplementedIndexingServiceServer) IndexSMBFiles(*IndexSMBFilesRequest, grpc.ServerStreamingServer[TaskProgress]) error {
	return status.Error(codes.Unimplemented, "method IndexSMBFiles not implemented")
}
func (UnimplementedIndexingServiceServer) CancelTask(context.Context, *CancelTaskRequest) (*CancelTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelTask not implemented")
}
func (UnimplementedIndexingServiceServer) mustEmbedUnimplementedIndexingServiceServer() {}
func (UnimplementedIndexingServiceServer) testEmbeddedByValue()                         {}

// UnsafeIndexingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IndexingServiceServer will
// result in compilation errors.
type UnsafeIndexingServiceServer interface {
	mustEmbedUnimplementedIndexingServiceServer()
}

func RegisterIndexingServiceServer(s grpc.ServiceRegistrar, srv IndexingServiceServer) {
	// If the following call panics, it indicates UnimplementedIndexingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&IndexingService_ServiceDesc, srv)
}

func _IndexingService_IndexCodebase_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IndexCodebaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IndexingServiceServer).IndexCodebase(m, &grpc.GenericServerStream[IndexCodebaseRequest, TaskProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type IndexingService_IndexCodebaseServer = grpc.ServerStreamingServer[TaskProgress]

func _IndexingService_IndexDocuments_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IndexDocumentsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IndexingServiceServer).IndexDocuments(m, &grpc.GenericServerStream[IndexDocumentsRequest, TaskProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type IndexingService_IndexDocumentsServer = grpc.ServerStreamingServer[TaskProgress]

func _IndexingService_IndexImages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IndexImagesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IndexingServiceServer).IndexImages(m, &grpc.GenericServerStream[IndexImagesRequest, TaskProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type IndexingService_IndexImagesServer = grpc.ServerStreamingServer[TaskProgress]

func _IndexingService_IndexUploads_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IndexUploadsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IndexingServiceServer).IndexUploads(m, &grpc.GenericServerStream[IndexUploadsRequest, TaskProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type IndexingService_IndexUploadsServer = grpc.ServerStreamingServer[TaskProgress]

func _IndexingService_IndexSMBFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IndexSMBFilesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IndexingServiceServer).IndexSMBFiles(m, &grpc.GenericServerStream[IndexSMBFilesRequest, TaskProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type IndexingService_IndexSMBFilesServer = grpc.ServerStreamingServer[TaskProgress]

func _IndexingService_CancelTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexingServiceServer).CancelTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IndexingService_CancelTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexingServiceServer).CancelTask(ctx, req.(*CancelTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IndexingService_ServiceDesc is the grpc.ServiceDesc for IndexingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IndexingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ollqd.v1.IndexingService",
	HandlerType: (*IndexingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CancelTask",
			Handler:    _IndexingService_CancelTask_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "IndexCodebase",
			Handler:       _IndexingService_IndexCodebase_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "IndexDocuments",
			Handler:       _IndexingService_IndexDocuments_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "IndexImages",
			Handler:       _IndexingService_IndexImages_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "IndexUploads",
			Handler:       _IndexingService_IndexUploads_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "IndexSMBFiles",
			Handler:       _IndexingService_IndexSMBFiles_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ollqd/v1/processing.proto",
}

const (
	SearchService_Search_FullMethodName           = "/ollqd.v1.SearchService/Search"
	SearchService_SearchCollection_FullMethodName = "/ollqd.v1.SearchService/SearchCollection"
)

// SearchServiceClient is the client API for SearchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SearchServiceClient interface {
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	SearchCollection(ctx context.Context, in *SearchCollectionRequest, opts ...grpc.CallOption) (*SearchResponse, error)
}

type searchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSearchServiceClient(cc grpc.ClientConnInterface) SearchServiceClient {
	return &searchServiceClient{cc}
}

func (c *searchServiceClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, SearchService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) SearchCollection(ctx context.Context, in *SearchCollectionRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, SearchService_SearchCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SearchServiceServer is the server API for SearchService service.
// All implementations must embed UnimplementedSearchServiceServer
// for forward compatibility.
type SearchServiceServer interface {
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	SearchCollection(context.Context, *SearchCollectionRequest) (*SearchResponse, error)
	mustEmbedUnimplementedSearchServiceServer()
}

// UnimplementedSearchServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSearchServiceServer struct{}

func (UnimplementedSearchServiceServer) Search(context.Context, *SearchRequest) (*SearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedSearchServiceServer) SearchCollection(context.Context, *SearchCollectionRequest) (*SearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchCollection not implemented")
}
func (UnimplementedSearchServiceServer) mustEmbedUnimplementedSearchServiceServer() {}
func (UnimplementedSearchServiceServer) testEmbeddedByValue()                       {}

// UnsafeSearchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SearchServiceServer will
// result in compilation errors.
type UnsafeSearchServiceServer interface {
	mustEmbedUnimplementedSearchServiceServer()
}

func RegisterSearchServiceServer(s grpc.ServiceRegistrar, srv SearchServiceServer) {
	// If the following call panics, it indicates UnimplementedSearchServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SearchService_ServiceDesc, srv)
}

func _SearchService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_SearchCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_SearchCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchCollection(ctx, req.(*SearchCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SearchService_ServiceDesc is the grpc.ServiceDesc for SearchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SearchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ollqd.v1.SearchService",
	HandlerType: (*SearchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _SearchService_Search_Handler,
		},
		{
			MethodName: "SearchCollection",
			Handler:    _SearchService_SearchCollection_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ollqd/v1/processing.proto",
}

const (
	ChatService_Chat_FullMethodName = "/ollqd.v1.ChatService/Chat"
)

// ChatServiceClient is the client API for ChatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChatServiceClient interface {
	Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatEvent], error)
}

type chatServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChatServiceClient(cc grpc.ClientConnInterface) ChatServiceClient {
	return &chatServiceClient{cc}
}

func (c *chatServiceClient) Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[0], ChatService_Chat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ChatRequest, ChatEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_ChatClient = grpc.ServerStreamingClient[ChatEvent]

// ChatServiceServer is the server API for ChatService service.
// All implementations must embed UnimplementedChatServiceServer
// for forward compatibility.
type ChatServiceServer interface {
	Chat(*ChatRequest, grpc.ServerStreamingServer[ChatEvent]) error
	mustEmbedUnimplementedChatServiceServer()
}

// UnimplementedChatServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChatServiceServer struct{}

func (UnimplementedChatServiceServer) Chat(*ChatRequest, grpc.ServerStreamingServer[ChatEvent]) error {
	return status.Error(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedChatServiceServer) mustEmbedUnimplementedChatServiceServer() {}
func (UnimplementedChatServiceServer) testEmbeddedByValue()                     {}

// UnsafeChatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatServiceServer will
// result in compilation errors.
type UnsafeChatServiceServer interface {
	mustEmbedUnimplementedChatServiceServer()
}

func RegisterChatServiceServer(s grpc.ServiceRegistrar, srv ChatServiceServer) {
	// If the following call panics, it indicates UnimplementedChatServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChatService_ServiceDesc, srv)
}

func _ChatService_Chat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServiceServer).Chat(m, &grpc.GenericServerStream[ChatRequest, ChatEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_ChatServer = grpc.ServerStreamingServer[ChatEvent]

// ChatService_ServiceDesc is the grpc.ServiceDesc for ChatService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ollqd.v1.ChatService",
	HandlerType: (*ChatServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Chat",
			Handler:       _ChatService_Chat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ollqd/v1/processing.proto",
}

const (
	EmbeddingService_GetInfo_FullMethodName       = "/ollqd.v1.EmbeddingService/GetInfo"
	EmbeddingService_TestEmbed_FullMethodName     = "/ollqd.v1.EmbeddingService/TestEmbed"
	EmbeddingService_CompareModels_FullMethodName = "/ollqd.v1.EmbeddingService/CompareModels"
	EmbeddingService_SetModel_FullMethodName      = "/ollqd.v1.EmbeddingService/SetModel"
)

// EmbeddingServiceClient is the client API for EmbeddingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EmbeddingServiceClient interface {
	GetInfo(ctx context.Context, in *GetEmbeddingInfoRequest, opts ...grpc.CallOption) (*EmbeddingInfoResponse, error)
	TestEmbed(ctx context.Context, in *TestEmbedRequest, opts ...grpc.CallOption) (*TestEmbedResponse, error)
	CompareModels(ctx context.Context, in *CompareModelsRequest, opts ...grpc.CallOption) (*CompareModelsResponse, error)
	SetModel(ctx context.Context, in *SetEmbedModelRequest, opts ...grpc.CallOption) (*EmbeddingInfoResponse, error)
}

type embeddingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEmbeddingServiceClient(cc grpc.ClientConnInterface) EmbeddingServiceClient {
	return &embeddingServiceClient{cc}
}

func (c *embeddingServiceClient) GetInfo(ctx context.Context, in *GetEmbeddingInfoRequest, opts ...grpc.CallOption) (*EmbeddingInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingInfoResponse)
	err := c.cc.Invoke(ctx, EmbeddingService_GetInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *embeddingServiceClient) TestEmbed(ctx context.Context, in *TestEmbedRequest, opts ...grpc.CallOption) (*TestEmbedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestEmbedResponse)
	err := c.cc.Invoke(ctx, EmbeddingService_TestEmbed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *embeddingServiceClient) CompareModels(ctx context.Context, in *CompareModelsRequest, opts ...grpc.CallOption) (*CompareModelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompareModelsResponse)
	err := c.cc.Invoke(ctx, EmbeddingService_CompareModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *embeddingServiceClient) SetModel(ctx context.Context, in *SetEmbedModelRequest, opts ...grpc.CallOption) (*EmbeddingInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingInfoResponse)
	err := c.cc.Invoke(ctx, EmbeddingService_SetModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EmbeddingServiceServer is the server API for EmbeddingService service.
// All implementations must embed UnimplementedEmbeddingServiceServer
// for forward compatibility.
type EmbeddingServiceServer interface {
	GetInfo(context.Context, *GetEmbeddingInfoRequest) (*EmbeddingInfoResponse, error)
	TestEmbed(context.Context, *TestEmbedRequest) (*TestEmbedResponse, error)
	CompareModels(context.Context, *CompareModelsRequest) (*CompareModelsResponse, error)
	SetModel(context.Context, *SetEmbedModelRequest) (*EmbeddingInfoResponse, error)
	mustEmbedUnimplementedEmbeddingServiceServer()
}

// UnimplementedEmbeddingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEmbeddingServiceServer struct{}

func (UnimplementedEmbeddingServiceServer) GetInfo(context.Context, *GetEmbeddingInfoRequest) (*EmbeddingInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetInfo not implemented")
}
func (UnimplementedEmbeddingServiceServer) TestEmbed(context.Context, *TestEmbedRequest) (*TestEmbedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TestEmbed not implemented")
}
func (UnimplementedEmbeddingServiceServer) CompareModels(context.Context, *CompareModelsRequest) (*CompareModelsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CompareModels not implemented")
}
func (UnimplementedEmbeddingServiceServer) SetModel(context.Context, *SetEmbedModelRequest) (*EmbeddingInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetModel not implemented")
}
func (UnimplementedEmbeddingServiceServer) mustEmbedUnimplementedEmbeddingServiceServer() {}
func (UnimplementedEmbeddingServiceServer) testEmbeddedByValue()                          {}

// UnsafeEmbeddingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EmbeddingServiceServer will
// result in compilation errors.
type UnsafeEmbeddingServiceServer interface {
	mustEmbedUnimplementedEmbeddingServiceServer()
}

func RegisterEmbeddingServiceServer(s grpc.ServiceRegistrar, srv EmbeddingServiceServer) {
	// If the following call panics, it indicates UnimplementedEmbeddingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EmbeddingService_ServiceDesc, srv)
}

func _EmbeddingService_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEmbeddingInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmbeddingServiceServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmbeddingService_GetInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmbeddingServiceServer).GetInfo(ctx, req.(*GetEmbeddingInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmbeddingService_TestEmbed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestEmbedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmbeddingServiceServer).TestEmbed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmbeddingService_TestEmbed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmbeddingServiceServer).TestEmbed(ctx, req.(*TestEmbedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmbeddingService_CompareModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompareModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmbeddingServiceServer).CompareModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmbeddingService_CompareModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmbeddingServiceServer).CompareModels(ctx, req.(*CompareModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmbeddingService_SetModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetEmbedModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmbeddingServiceServer).SetModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmbeddingService_SetModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmbeddingServiceServer).SetModel(ctx, req.(*SetEmbedModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EmbeddingService_ServiceDesc is the grpc.ServiceDesc for EmbeddingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EmbeddingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ollqd.v1.EmbeddingService",
	HandlerType: (*EmbeddingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInfo",
			Handler:    _EmbeddingService_GetInfo_Handler,
		},
		{
			MethodName: "TestEmbed",
			Handler:    _EmbeddingService_TestEmbed_Handler,
		},
		{
			MethodName: "CompareModels",
			Handler:    _EmbeddingService_CompareModels_Handler,
		},
		{
			MethodName: "SetModel",
			Handler:    _EmbeddingService_SetModel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ollqd/v1/processing.proto",
}

const (
	PIIService_TestMasking_FullMethodName = "/ollqd.v1.PIIService/TestMasking"
)

// PIIServiceClient is the client API for PIIService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PIIServiceClient interface {
	TestMasking(ctx context.Context, in *TestMaskingRequest, opts ...grpc.CallOption) (*TestMaskingResponse, error)
}

type pIIServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPIIServiceClient(cc grpc.ClientConnInterface) PIIServiceClient {
	return &pIIServiceClient{cc}
}

func (c *pIIServiceClient) TestMasking(ctx context.Context, in *TestMaskingRequest, opts ...grpc.CallOption) (*TestMaskingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestMaskingResponse)
	err := c.cc.Invoke(ctx, PIIService_TestMasking_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PIIServiceServer is the server API for PIIService service.
// All implementations must embed UnimplementedPIIServiceServer
// for forward compatibility.
type PIIServiceServer interface {
	TestMasking(context.Context, *TestMaskingRequest) (*TestMaskingResponse, error)
	mustEmbedUnimplementedPIIServiceServer()
}

// UnimplementedPIIServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPIIServiceServer struct{}

func (UnimplementedPIIServiceServer) TestMasking(context.Context, *TestMaskingRequest) (*TestMaskingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TestMasking not implemented")
}
func (UnimplementedPIIServiceServer) mustEmbedUnimplementedPIIServiceServer() {}
func (UnimplementedPIIServiceServer) testEmbeddedByValue()                    {}

// UnsafePIIServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PIIServiceServer will
// result in compilation errors.
type UnsafePIIServiceServer interface {
	mustEmbedUnimplementedPIIServiceServer()
}

func RegisterPIIServiceServer(s grpc.ServiceRegistrar, srv PIIServiceServer) {
	// If the following call panics, it indicates UnimplementedPIIServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PIIService_ServiceDesc, srv)
}

func _PIIService_TestMasking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestMaskingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PIIServiceServer).TestMasking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PIIService_TestMasking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PIIServiceServer).TestMasking(ctx, req.(*TestMaskingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PIIService_ServiceDesc is the grpc.ServiceDesc for PIIService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PIIService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ollqd.v1.PIIService",
	HandlerType: (*PIIServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TestMasking",
			Handler:    _PIIService_TestMasking_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ollqd/v1/processing.proto",
}

const (
	ConfigService_GetConfig_FullMethodName          = "/ollqd.v1.ConfigService/GetConfig"
	ConfigService_UpdateMountedPaths_FullMethodName = "/ollqd.v1.ConfigService/UpdateMountedPaths"
	ConfigService_UpdatePII_FullMethodName          = "/ollqd.v1.ConfigService/UpdatePII"
	ConfigService_UpdateDocling_FullMethodName      = "/ollqd.v1.ConfigService/UpdateDocling"
	ConfigService_UpdateDistance_FullMethodName     = "/ollqd.v1.ConfigService/UpdateDistance"
	ConfigService_GetPIIConfig_FullMethodName       = "/ollqd.v1.ConfigService/GetPIIConfig"
	ConfigService_GetDoclingConfig_FullMethodName   = "/ollqd.v1.ConfigService/GetDoclingConfig"
	ConfigService_ResetConfig_FullMethodName        = "/ollqd.v1.ConfigService/ResetConfig"
)

// ConfigServiceClient is the client API for ConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConfigServiceClient interface {
	GetConfig(ctx context.Context, in *GetConfigRequest, opts ...grpc.CallOption) (*AppConfig, error)
	UpdateMountedPaths(ctx context.Context, in *UpdateMountedPathsRequest, opts ...grpc.CallOption) (*UpdateMountedPathsResponse, error)
	UpdatePII(ctx context.Context, in *UpdatePIIRequest, opts ...grpc.CallOption) (*PIIConfigResponse, error)
	UpdateDocling(ctx context.Context, in *UpdateDoclingRequest, opts ...grpc.CallOption) (*DoclingConfigResponse, error)
	UpdateDistance(ctx context.Context, in *UpdateDistanceRequest, opts ...grpc.CallOption) (*UpdateDistanceResponse, error)
	GetPIIConfig(ctx context.Context, in *GetPIIConfigRequest, opts ...grpc.CallOption) (*PIIConfigResponse, error)
	GetDoclingConfig(ctx context.Context, in *GetDoclingConfigRequest, opts ...grpc.CallOption) (*DoclingConfigResponse, error)
	ResetConfig(ctx context.Context, in *ResetConfigRequest, opts ...grpc.CallOption) (*ResetConfigResponse, error)
}

type configServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigServiceClient(cc grpc.ClientConnInterface) ConfigServiceClient {
	return &configServiceClient{cc}
}

func (c *configServiceClient) GetConfig(ctx context.Context, in *GetConfigRequest, opts ...grpc.CallOption) (*AppConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AppConfig)
	err := c.cc.Invoke(ctx, ConfigService_GetConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) UpdateMountedPaths(ctx context.Context, in *UpdateMountedPathsRequest, opts ...grpc.CallOption) (*UpdateMountedPathsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateMountedPathsResponse)
	err := c.cc.Invoke(ctx, ConfigService_UpdateMountedPaths_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) UpdatePII(ctx context.Context, in *UpdatePIIRequest, opts ...grpc.CallOption) (*PIIConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PIIConfigResponse)
	err := c.cc.Invoke(ctx, ConfigService_UpdatePII_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) UpdateDocling(ctx context.Context, in *UpdateDoclingRequest, opts ...grpc.CallOption) (*DoclingConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DoclingConfigResponse)
	err := c.cc.Invoke(ctx, ConfigService_UpdateDocling_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) UpdateDistance(ctx context.Context, in *UpdateDistanceRequest, opts ...grpc.CallOption) (*UpdateDistanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateDistanceResponse)
	err := c.cc.Invoke(ctx, ConfigService_UpdateDistance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) GetPIIConfig(ctx context.Context, in *GetPIIConfigRequest, opts ...grpc.CallOption) (*PIIConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PIIConfigResponse)
	err := c.cc.Invoke(ctx, ConfigService_GetPIIConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) GetDoclingConfig(ctx context.Context, in *GetDoclingConfigRequest, opts ...grpc.CallOption) (*DoclingConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DoclingConfigResponse)
	err := c.cc.Invoke(ctx, ConfigService_GetDoclingConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) ResetConfig(ctx context.Context, in *ResetConfigRequest, opts ...grpc.CallOption) (*ResetConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetConfigResponse)
	err := c.cc.Invoke(ctx, ConfigService_ResetConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigServiceServer is the server API for ConfigService service.
// All implementations must embed UnimplementedConfigServiceServer
// for forward compatibility.
type ConfigServiceServer interface {
	GetConfig(context.Context, *GetConfigRequest) (*AppConfig, error)
	UpdateMountedPaths(context.Context, *UpdateMountedPathsRequest) (*UpdateMountedPathsResponse, error)
	UpdatePII(context.Context, *UpdatePIIRequest) (*PIIConfigResponse, error)
	UpdateDocling(context.Context, *UpdateDoclingRequest) (*DoclingConfigResponse, error)
	UpdateDistance(context.Context, *UpdateDistanceRequest) (*UpdateDistanceResponse, error)
	GetPIIConfig(context.Context, *GetPIIConfigRequest) (*PIIConfigResponse, error)
	GetDoclingConfig(context.Context, *GetDoclingConfigRequest) (*DoclingConfigResponse, error)
	ResetConfig(context.Context, *ResetConfigRequest) (*ResetConfigResponse, error)
	mustEmbedUnimplementedConfigServiceServer()
}

// UnimplementedConfigServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConfigServiceServer struct{}

func (UnimplementedConfigServiceServer) GetConfig(context.Context, *GetConfigRequest) (*AppConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConfig not implemented")
}
func (UnimplementedConfigServiceServer) UpdateMountedPaths(context.Context, *UpdateMountedPathsRequest) (*UpdateMountedPathsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateMountedPaths not implemented")
}
func (UnimplementedConfigServiceServer) UpdatePII(context.Context, *UpdatePIIRequest) (*PIIConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePII not implemented")
}
func (UnimplementedConfigServiceServer) UpdateDocling(context.Context, *UpdateDoclingRequest) (*DoclingConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateDocling not implemented")
}
func (UnimplementedConfigServiceServer) UpdateDistance(context.Context, *UpdateDistanceRequest) (*UpdateDistanceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateDistance not implemented")
}
func (UnimplementedConfigServiceServer) GetPIIConfig(context.Context, *GetPIIConfigRequest) (*PIIConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPIIConfig not implemented")
}
func (UnimplementedConfigServiceServer) GetDoclingConfig(context.Context, *GetDoclingConfigRequest) (*DoclingConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDoclingConfig not implemented")
}
func (UnimplementedConfigServiceServer) ResetConfig(context.Context, *ResetConfigRequest) (*ResetConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResetConfig not implemented")
}
func (UnimplementedConfigServiceServer) mustEmbedUnimplementedConfigServiceServer() {}
func (UnimplementedConfigServiceServer) testEmbeddedByValue()                       {}

// UnsafeConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfigServiceServer will
// result in compilation errors.
type UnsafeConfigServiceServer interface {
	mustEmbedUnimplementedConfigServiceServer()
}

func RegisterConfigServiceServer(s grpc.ServiceRegistrar, srv ConfigServiceServer) {
	// If the following call panics, it indicates UnimplementedConfigServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConfigService_ServiceDesc, srv)
}

func _ConfigService_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_GetConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).GetConfig(ctx, req.(*GetConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_UpdateMountedPaths_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMountedPathsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).UpdateMountedPaths(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_UpdateMountedPaths_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).UpdateMountedPaths(ctx, req.(*UpdateMountedPathsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_UpdatePII_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePIIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).UpdatePII(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_UpdatePII_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).UpdatePII(ctx, req.(*UpdatePIIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_UpdateDocling_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDoclingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).UpdateDocling(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_UpdateDocling_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).UpdateDocling(ctx, req.(*UpdateDoclingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_UpdateDistance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDistanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).UpdateDistance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_UpdateDistance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).UpdateDistance(ctx, req.(*UpdateDistanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_GetPIIConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPIIConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).GetPIIConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_GetPIIConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).GetPIIConfig(ctx, req.(*GetPIIConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_GetDoclingConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDoclingConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).GetDoclingConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_GetDoclingConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).GetDoclingConfig(ctx, req.(*GetDoclingConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_ResetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).ResetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_ResetConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).ResetConfig(ctx, req.(*ResetConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConfigService_ServiceDesc is the grpc.ServiceDesc for ConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ollqd.v1.ConfigService",
	HandlerType: (*ConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConfig",
			Handler:    _ConfigService_GetConfig_Handler,
		},
		{
			MethodName: "UpdateMountedPaths",
			Handler:    _ConfigService_UpdateMountedPaths_Handler,
		},
		{
			MethodName: "UpdatePII",
			Handler:    _ConfigService_UpdatePII_Handler,
		},
		{
			MethodName: "UpdateDocling",
			Handler:    _ConfigService_UpdateDocling_Handler,
		},
		{
			MethodName: "UpdateDistance",
			Handler:    _ConfigService_UpdateDistance_Handler,
		},
		{
			MethodName: "GetPIIConfig",
			Handler:    _ConfigService_GetPIIConfig_Handler,
		},
		{
			MethodName: "GetDoclingConfig",
			Handler:    _ConfigService_GetDoclingConfig_Handler,
		},
		{
			MethodName: "ResetConfig",
			Handler:    _ConfigService_ResetConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ollqd/v1/processing.proto",
}

const (
	VisualizationService_Overview_FullMethodName = "/ollqd.v1.VisualizationService/Overview"
	VisualizationService_FileTree_FullMethodName = "/ollqd.v1.VisualizationService/FileTree"
	VisualizationService_Vectors_FullMethodName  = "/ollqd.v1.VisualizationService/Vectors"
)

// VisualizationServiceClient is the client API for VisualizationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VisualizationServiceClient interface {
	Overview(ctx context.Context, in *OverviewRequest, opts ...grpc.CallOption) (*OverviewResponse, error)
	FileTree(ctx context.Context, in *FileTreeRequest, opts ...grpc.CallOption) (*FileTreeResponse, error)
	Vectors(ctx context.Context, in *VectorsRequest, opts ...grpc.CallOption) (*VectorsResponse, error)
}

type visualizationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVisualizationServiceClient(cc grpc.ClientConnInterface) VisualizationServiceClient {
	return &visualizationServiceClient{cc}
}

func (c *visualizationServiceClient) Overview(ctx context.Context, in *OverviewRequest, opts ...grpc.CallOption) (*OverviewResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OverviewResponse)
	err := c.cc.Invoke(ctx, VisualizationService_Overview_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *visualizationServiceClient) FileTree(ctx context.Context, in *FileTreeRequest, opts ...grpc.CallOption) (*FileTreeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileTreeResponse)
	err := c.cc.Invoke(ctx, VisualizationService_FileTree_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *visualizationServiceClient) Vectors(ctx context.Context, in *VectorsRequest, opts ...grpc.CallOption) (*VectorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VectorsResponse)
	err := c.cc.Invoke(ctx, VisualizationService_Vectors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VisualizationServiceServer is the server API for VisualizationService service.
// All implementations must embed UnimplementedVisualizationServiceServer
// for forward compatibility.
type VisualizationServiceServer interface {
	Overview(context.Context, *OverviewRequest) (*OverviewResponse, error)
	FileTree(context.Context, *FileTreeRequest) (*FileTreeResponse, error)
	Vectors(context.Context, *VectorsRequest) (*VectorsResponse, error)
	mustEmbedUnimplementedVisualizationServiceServer()
}

// UnimplementedVisualizationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVisualizationServiceServer struct{}

func (UnimplementedVisualizationServiceServer) Overview(context.Context, *OverviewRequest) (*OverviewResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Overview not implemented")
}
func (UnimplementedVisualizationServiceServer) FileTree(context.Context, *FileTreeRequest) (*FileTreeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FileTree not implemented")
}
func (UnimplementedVisualizationServiceServer) Vectors(context.Context, *VectorsRequest) (*VectorsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Vectors not implemented")
}
func (UnimplementedVisualizationServiceServer) mustEmbedUnimplementedVisualizationServiceServer() {}
func (UnimplementedVisualizationServiceServer) testEmbeddedByValue()                              {}

// UnsafeVisualizationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VisualizationServiceServer will
// result in compilation errors.
type UnsafeVisualizationServiceServer interface {
	mustEmbedUnimplementedVisualizationServiceServer()
}

func RegisterVisualizationServiceServer(s grpc.ServiceRegistrar, srv VisualizationServiceServer) {
	// If the following call panics, it indicates UnimplementedVisualizationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VisualizationService_ServiceDesc, srv)
}

func _VisualizationService_Overview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OverviewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VisualizationServiceServer).Overview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VisualizationService_Overview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VisualizationServiceServer).Overview(ctx, req.(*OverviewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VisualizationService_FileTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileTreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VisualizationServiceServer).FileTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VisualizationService_FileTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VisualizationServiceServer).FileTree(ctx, req.(*FileTreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VisualizationService_Vectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VectorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VisualizationServiceServer).Vectors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VisualizationService_Vectors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VisualizationServiceServer).Vectors(ctx, req.(*VectorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VisualizationService_ServiceDesc is the grpc.ServiceDesc for VisualizationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VisualizationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ollqd.v1.VisualizationService",
	HandlerType: (*VisualizationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Overview",
			Handler:    _VisualizationService_Overview_Handler,
		},
		{
			MethodName: "FileTree",
			Handler:    _VisualizationService_FileTree_Handler,
		},
		{
			MethodName: "Vectors",
			Handler:    _VisualizationService_Vectors_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ollqd/v1/processing.proto",
}

const (
	SMBService_TestConnection_FullMethodName = "/ollqd.v1.SMBService/TestConnection"
	SMBService_Browse_FullMethodName         = "/ollqd.v1.SMBService/Browse"
)

// SMBServiceClient is the client API for SMBService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SMBServiceClient interface {
	TestConnection(ctx context.Context, in *SMBTestRequest, opts ...grpc.CallOption) (*SMBTestResponse, error)
	Browse(ctx context.Context, in *SMBBrowseRequest, opts ...grpc.CallOption) (*SMBBrowseResponse, error)
}

type sMBServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSMBServiceClient(cc grpc.ClientConnInterface) SMBServiceClient {
	return &sMBServiceClient{cc}
}

func (c *sMBServiceClient) TestConnection(ctx context.Context, in *SMBTestRequest, opts ...grpc.CallOption) (*SMBTestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SMBTestResponse)
	err := c.cc.Invoke(ctx, SMBService_TestConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sMBServiceClient) Browse(ctx context.Context, in *SMBBrowseRequest, opts ...grpc.CallOption) (*SMBBrowseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SMBBrowseResponse)
	err := c.cc.Invoke(ctx, SMBService_Browse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SMBServiceServer is the server API for SMBService service.
// All implementations must embed UnimplementedSMBServiceServer
// for forward compatibility.
type SMBServiceServer interface {
	TestConnection(context.Context, *SMBTestRequest) (*SMBTestResponse, error)
	Browse(context.Context, *SMBBrowseRequest) (*SMBBrowseResponse, error)
	mustEmbedUnimplementedSMBServiceServer()
}

// UnimplementedSMBServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSMBServiceServer struct{}

func (UnimplementedSMBServiceServer) TestConnection(context.Context, *SMBTestRequest) (*SMBTestResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TestConnection not implemented")
}
func (UnimplementedSMBServiceServer) Browse(context.Context, *SMBBrowseRequest) (*SMBBrowseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Browse not implemented")
}
func (UnimplementedSMBServiceServer) mustEmbedUnimplementedSMBServiceServer() {}
func (UnimplementedSMBServiceServer) testEmbeddedByValue()                    {}

// UnsafeSMBServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SMBServiceServer will
// result in compilation errors.
type UnsafeSMBServiceServer interface {
	mustEmbedUnimplementedSMBServiceServer()
}

func RegisterSMBServiceServer(s grpc.ServiceRegistrar, srv SMBServiceServer) {
	// If the following call panics, it indicates UnimplementedSMBServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SMBService_ServiceDesc, srv)
}

func _SMBService_TestConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SMBTestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMBServiceServer).TestConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SMBService_TestConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMBServiceServer).TestConnection(ctx, req.(*SMBTestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SMBService_Browse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SMBBrowseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SMBServiceServer).Browse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SMBService_Browse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SMBServiceServer).Browse(ctx, req.(*SMBBrowseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SMBService_ServiceDesc is the grpc.ServiceDesc for SMBService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SMBService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ollqd.v1.SMBService",
	HandlerType: (*SMBServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TestConnection",
			Handler:    _SMBService_TestConnection_Handler,
		},
		{
			MethodName: "Browse",
			Handler:    _SMBService_Browse_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ollqd/v1/processing.proto",
}
